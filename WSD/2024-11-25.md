## Domain Driven Design
- Домен - предметная область
- Эксперт домена - специалист в выбранной области (примерно соответствует product owner-у в скраме (человеку, отвечающему за разрабатываемый продукт. Представляет заказчика, на каждом спринте подтверждает курс или вносит правки. Если не представитель заказчика, то представитель компании-разработчика))
- Порядок разработки
	- Составление тезауруса - словаря, в котором поясняются все термины домена, это называется языком (набор однозначно определённых терминов)
	- Выделение ограниченных контекстов (имён)
	- Определение контрактов - интерфейсов взаимодействия между выделенными контекстами. У контрактов есть имена. Контракты описывают команды, которые приводят к изменению состояния контекста, и события, оповещающие об изменении состояния и на которые могут быть подписаны прочие контексты
	- Описание контекстов
- Выделяются отдельные модули, имеющие высокую степень независимости (речь идёт о микросервисах)
- Пишется документация на определённом вначале языке (с использованием заранее определённых терминов)
- Ложится на водопадную модель, потому что инкрементальной разработки нет, подходит для разработки больших проектов
## CQRS
- **Command-Query responsibility segregation** - разделение ответственности на команды и запросы
- **CQS - command-query separation** - принцип императивного программирования
	- Пишем **в стиле** языка ассемблера (особенности ассемблера - у команд есть свой эффект (запись чего-то в регистре, например), и следующая команда выполняется на основе результата предыдущей выполненной команды). Команда пишется так, что она выполняет какое-то действие и закончила работу, а следующая команда либо использует результат предыдущей команды, либо делает что-то своё
	- Такое программирование называется императивным
- Всё в CQRS делится на два типа
	- Команды (функции): никак не зависимы, считывают какое-то общее состояние, выполняются, записывают куда-то новое состояние. Не имеют побочных эффектов (не используют глобальные переменные, не записывают ничего в глобальные переменные). Только записывают состояние
	- Запросы: только считывают состояние
- Как бы создаётся виртуальная машина / виртуальный процессор, способный выполнять команды и запросы
- Используется понятие **контрактное программирование** - жёсткая спецификация методов интерфейсов.
	- Предусловие - часть метода с проверкой входных параметров. Если проверка провалена, выбрасывается исключение
	- Постусловие - где формируется результат работы
	- Инвариант - обязательное соглашение в каждом методе. В каждом методе может быть определено что-то обязательное (что?)
- *Картинка в лекции с треугольником из UI, Read Model, Domain*
	- БД для записи - особый тип БД (даже не совсем БД, как будто это очередь) (подход event sourcing, где сохраняются не данные, а команды на изменение данных. При поступлении команды она помещается в очередь)
	- БД для чтения - ненормализованная БД, заточенная на обработку запросов (queries)
	- Используются обработчики событий, выгребающие команды и выполняющие их
## Event sourcing
- Подход к хранению данных, при котором хранятся не данные, а события
	- Используется не БД, а специализированная очередь
- Предполагается, что команда является реакцией на события, например, в UI
- Каждая команда имеет своё имя
- *Схема с круговоротом из лекции*
- Как правило, в СУБД, реализующей event store, есть механизм event handlers, который асинхронно сгребает события и применяет изменения
- Данный подход ложится на CQRS
#### Event Store
- База данных, заточенная под event sourcing, как пример (Javascript)
- Есть консольная утилита
- Есть веб-морда с дашбордами для отслеживания состояния БД
## Итоги
- Есть три основных момента
	- Есть методология проектирования DDD (ничего особенного, та же декомпозиция, но более строгая, основанная на Тезаурус)
	- Есть методология CQRS, основанная на императивном программировании двух сущностей: команд и запросов. Такой подход переносится на микросервисную архитектуру, в этом случае все данные, которые возникают в системе, записываются в специальную БД для записи, а читаются из специальной БД для чтения, и между ними есть какая-то репликация (принцип разделения ответственности, перенесённый на архитектуру)
	- БД для записи часто реализуется в виде баз данных Event sourcing: не идёт обновление данных в БД, а записываются команды, и специальным механизмом в соответствии с командами БД для чтения изменяет состояние
- Есть специальные БД, поддерживающие очереди команд с возможностью записи, считывания, обработки событий (обработчики запускаются при появлении нового элемента в очереди и обновляют хранилище для чтения)